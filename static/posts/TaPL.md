----
title: 型システム入門(TaPL)読書メモ
description: TaPLのメモです。
date: 2016-09-15
tags: haskell, book, memo, programming, math
----

TaPLでの読書メモが書いてあります随時追記していきます。
間違いを発見した場合はコメントか、me [at] eliza [dot] linkまでメールを下さると喜びます。

[日本語のサポートページ](http://tapl.proofcafe.org/home)が準備されています。
また、[出版元のページ](https://estore.ohmsha.co.jp/titles/978427406911P)から第一章が無料で読めます。

通読したのちにまた記事を書こうと思っています。

<!--more-->

## 予備知識について

[このページに書いてあります](/posts/PreTaPL.html)

## TaPL

> 型システムとは、プログラミング言語の安全性や効率を高めるうえで重要な理論・手法です。本書は、その型システムについて基礎的な話題を網羅し、実装例を交えて丁寧に解説したThe MIT Press発行の解説書“Types And Programming Languages”（TAPL）を翻訳したものです。言語設計者や学生だけでなく、静的型付言語を深く理解して活用したいプログラマーにとっても貴重な情報となっています。
> <http://shop.ohmsha.co.jp/shop/shopdetail.html?brandcode=000000001948>

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">サポートサイトができたらジュンク堂トークのPDFも載ると思いますが、これだけは先に：型システム入門(TAPL)はとりあえず1,3,8,5,9,11章（＆2章の必要な部分）と、あとは好きな章を読めば「読んだ」ことにしても良いと思います！（60%本気）</p>&mdash; Eijiro Sumii (@esumii) <a href="https://twitter.com/esumii/status/315135694462939137">2013年3月22日</a></blockquote>

以降読書メモです

#### 第1章	はじめに
型を導入する意義や、型システムの実用例が書かれています。

#### 第2章	数学的準備
_- 数学の公式や前提として必要な知識が列挙されています、ここで馴染の無い物があれば読むのを中断し、いちどその分野の知識を補うべきだとしていますが私は強行を決めました。
- 2017/05/07 勉強しました

## 第1部	型無しの計算体系

#### 第3章	型無し算術式
- 正規形
    + もう項が評価できない、という意味である。 `if t1 then t2 else t3` は評価できるが、 `true` はもう評価できない。
    + 項が正規形であるにかかわらず値ではない場合を『行き詰まり状態』と言う。
    + すべての項に対して、ある正規形が存在する
- 多ステップ評価
    + 1ステップ評価を合成したやつだと理解しておいた。

#### 第4章	算術式のML実装
- Arithで満たしている機能と色々が含まれている言語を作りました。
- Mikan - <https://github.com/eliza0x/Mikan/tree/e62f16b277af3118dacdd8c7c3ea0655c2766713>

#### 第5章	型無しラムダ計算
- なんとなく分かったら、[ラムダ計算基礎文法最速マスター](http://tarao.hatenablog.com/entry/20100208/1265605429)にあっさりと書かれているので読むといいかも。
- $\lambda$(Lambda)計算
    + 全ての計算が関数定義と関数適用で表される(trueやfalse、数も関数!)
    + 複雑なプログラミング言語のエッセンスは小さな核となる計算の集まりとして定式化できる、という事で生まれた。
- Lambda計算はプログラミング言語であると共に証明可能な数学的対象。
- Lambda計算に似たようなものに$\pi$計算やオブジェクト計算がある(本書では扱わないらしいが)
    + [π-calculus 超入門](http://web.yl.is.s.u-tokyo.ac.jp/kobalab/kadai99/picalc.html)
    + もしかしてアクターモデルの原点？
- 自由変数の無い項を「閉じている」もしくは「コンビネータ」という。
    + $\lambda x.\; x$ 例えばこの恒等関数はコンビネータである。
    + $\lambda x.\; y$ この項はコンビネータではない。 
- $(\lambda x.\; x) y$ は $y$ と評価される。
- ラムダ計算の評価戦略は数種類あり、プログラミング言語によっても違う。
    + Haskellは名前呼び戦略の変種である必要呼び戦略
    + 大多数の言語では値呼び戦略
- 値呼び評価は「正格」名前呼び戦略は「非正格」もしくは「遅延評価」と呼ばれる。
- 純粋なラムダ計算でもブール値や数の表現と評価は出来る
    + 純粋なラムダ計算ではTrueとFalseを以下のように表現する。
    + $true\; =\; \lambda t.\; \lambda f.\; t;\\false\; =\; \lambda t.\; \lambda f.\; f;$
    + 面倒、なので必要に応じて拡張して使ったりする。
- 正規形に評価できない項が存在する。
    + $omega\; =\; (\lambda x. x\; x)\; (\lambda x. x\; x);$
    + 簡約基を一つだけ持っているが、簡約すると$omega$そのものになるためである。
    + これを発散という。
- $omega$コンビネータには不動点コンビネータと呼ばれる一般化がある。
    + Haskellが分かるならtanakh氏の[不動点演算子](http://d.hatena.ne.jp/tanakh/20040813)の記事が面白いかも。

#### 第6章	項の名無し表現

- [de Bruijn indexについての備忘録](http://ryna4c2e.hatenablog.com/entry/20141023/1414077068)が参考になると思います。
- 代入等を可能にするため、変数に適宜新しい名前を与えたい。
- そのためには様々な方法があります。
    + 本著では「de Bruijinインデックス」[^deBruin]を使用しています。
- de Bruijinインデックス
    + 変数を名前から解放したい。
    + 束縛しているLambdaからどれだけ遠い(深い)かを自然数で表します。
    + 例
        * $\lambda x.\; x \Rightarrow \lambda .\; 0$
        * $\lambda x.\lambda y.\; y\; x \Rightarrow \lambda.\lambda. \; 0\; 1$
        * $foo = (\lambda x. (\lambda x. x)) (\lambda x. x); \Rightarrow foo = (\lambda .\lambda . 0) (\lambda . 0);$
        * $\lambda$ の数より多い数値の場合、自由変数を指す。例えば $\lambda .1\; 0$ の $1$ は自由変数
    + 名無し項より自由変数を含むかどうか判別が簡単。
- シフト
    + de Bruijinインデックスを導入すると、代入の際自由変数のみインデックスを変更する必要が出てくる。

自由変数にインデックスを割り当てます。
$$
\gamma =    foo \mapsto 2 \\
\qquad      bar \mapsto 1 \\
\qquad\quad z   \mapsto 0
$$

Lambda式です。
$$
foo = \lambda x. \lambda y. z \\
bar = \lambda x. foo\; x
$$

変数をde Bruijinインデックスで表現します。
$$
foo = \lambda . \lambda . 2 \\
bar = \lambda . 3\; 0
$$

`foo`をインライン化します。
`bar`のLambdaの一つ内側に入る訳ですから、1個シフトする必要があります。^[数式に起こすと $\uparrow ^2 (\lambda . \lambda . 2)$]

$$
bar = \lambda . (\lambda . \lambda . 3)\; 0
$$

$\beta$簡約をしましょう。Lambdaが一つ減るたびに、インデックスを一小さくする必要があります。

$$
bar = \lambda . \lambda . 2
$$

[^deBruin]: 「de Brujin項」とも呼ばれるそうです。日本語ではド ブラウンと読むのが一番近いそうです。

<!-- #### 第7章	ラムダ計算のML実装 -->

## 第2部	単純型

#### 第8章	型付き算術式
- 進行定理
	+ 正しく型付けされた項は行き詰まり状態に陥らない。
- 保存定理
	+ 正しく型付けされた項が評価できるならば、評価後の項も正しく型付けされている。
- 以上二つの定理を満たしたものを型安全^[健全性とも言われる]である、と言われる。

<!--
  #### 第9章	単純型付きラムダ計算
  
  - Lambda抽象を型として扱う$\rightarrow$型
  	+ これだと$(\lambda x. 0) true$のような時に型がつけられない
  	+ これでは書きたいプログラムに型が割り当てられないことが多々ある
  
  ```haskell
  foo = if <長く複雑な式>
  	then true
  	else print "ERROR"
  ```
  
  このHaskellのプログラムでは型エラーでコンパイルが通らない。
  
  > ラムダ計算はチューリング完全なので正格な型解析は不可能である
  > -- P. 75 9.1章
  
  - ちょっとよく分からない
    ~ $omega$等発散してしまう場合に無限を扱えないため？
  
  - 型付きラムダ計算は$\lambda _\rightarrow$と表記される_
  - 導入規則: その型の要素がどのように作られるか
  - 除去規則: その型の要素がどのように使われるか
  - 論理学と型理論のふしぎな関連はCurry-Howard対応^[Curry-Howard同型ともよばれる]として知られている
  	+ [Haskell/カリー=ハワード同型](https://ja.wikibooks.org/wiki/Haskell/%E3%82%AB%E3%83%AA%E3%83%BC%3D%E3%83%8F%E3%83%AF%E3%83%BC%E3%83%89%E5%90%8C%E5%9E%8B)が面白い
  - 型注釈は評価においてはなんの役割も果たさない
  - たいていのプログラムは実行時に型無しの項にもどされる
    + [型安全なリストを作るのです(｀・ω・´) ～ その1、Phantom Type（幽霊型）入門ですー＞ω＜](https://kagamilove0707.github.io/programming/2014/02/20/about-phantom-type/)が面白い
-->

<!--
  #### 第10章	単純型のML実装
  #### 第11章	単純な拡張
  #### 第12章	正規化
  #### 第13章	参照
  #### 第14章	例外
  
  ## 第3部	部分型付け
  #### 第15章	部分型付け
  #### 第16章	部分型付けのメタ理論
  #### 第17章	部分型付けのML実装
  #### 第18章	事例：命令的オブジェクト
  #### 第19章	事例：Featherweight Java
  
  ## 第4部	再帰型
  #### 第20章	再帰型
  #### 第21章	再帰型のメタ理論
  
  ## 第5部	多相性
  #### 第22章	型再構築
  #### 第23章	全称型
  #### 第24章	存在型
  #### 第25章	System F のML実装
  #### 第26章	有界量化
  #### 第27章	事例：命令的オブジェクト再考
  #### 第28章	有界量化のメタ理論
  
  ## 第6部	高階の型システム
  #### 第29章	型演算子とカインド
  #### 第30章	高階多相
  #### 第31章	高階部分型付け
  #### 第32章	事例：純粋関数的オブジェクト
  
  ## 付録A	演習の解答
  ## 付録B	記法
-->
